# Мессенджер на основе криптосистемы Рабина

Это приложение демонстрирует работу криптосистемы Рабина в контексте защищенного обмена сообщениями.

## Криптосистема Рабина. Описание алгоритма

Криптосистема Рабина — это асимметричная криптосистема, предложенная Майклом Рабином в 1979 году. Её безопасность математически эквивалентна сложности факторизации больших чисел.

### Основные принципы

Криптосистема основана на сложности извлечения квадратного корня по модулю составного числа. Если известны простые множители этого числа, задача становится вычислительно простой, что и является основой для асимметричного шифрования.

### Математическая основа

Криптосистема Рабина опирается на следующие математические принципы:

1. **Квадратичные вычеты**: Если для числа a существует такое число x, что x² ≡ a (mod n), то a называется квадратичным вычетом по модулю n.
2. **Числа Блюма**: Простые числа вида p ≡ 3 (mod 4), то есть при делении на 4 дающие остаток 3.
3. **Китайская теорема об остатках**: Метод решения системы сравнений, используемый при расшифровании.

### Генерация ключей

1. Выбираем два больших простых числа p и q, где p ≡ 3 (mod 4) и q ≡ 3 (mod 4) — такие числа называются числами Блюма
2. Вычисляем n = p × q
3. **Открытый ключ**: n
4. **Закрытый ключ**: (p, q)

### Шифрование

Процесс шифрования в криптосистеме Рабина чрезвычайно прост:

1. Преобразуем сообщение m в число (убедившись, что m < n)
2. Вычисляем c = m² mod n
3. c — это зашифрованное сообщение

### Расшифрование

Расшифрование сложнее и требует знания закрытого ключа (p, q):

1. Вычисляем mp = c^((p+1)/4) mod p
2. Вычисляем mq = c^((q+1)/4) mod q
3. Используем расширенный алгоритм Евклида для нахождения коэффициентов Безу yp и yq, таких что yp·p + yq·q = 1
4. Получаем четыре возможных значения исходного сообщения:
   - r₁ = (yp·p·mq + yq·q·mp) mod n
   - r₂ = (yp·p·mq - yq·q·mp) mod n
   - r₃ = n - r₁
   - r₄ = n - r₂

## Сферы применения криптосистемы Рабина

Криптосистема Рабина находит применение в различных областях:

1. **Цифровые подписи**: Благодаря математической эквивалентности проблеме факторизации, криптосистема Рабина может использоваться для создания цифровых подписей.

2. **Защищенная передача данных**: Используется для шифрования конфиденциальной информации при передаче по незащищенным каналам.

3. **Протоколы аутентификации**: Может применяться в протоколах проверки подлинности без раскрытия секретной информации.

4. **Системы электронного голосования**: Используется для обеспечения анонимности и целостности голосов.

5. **Криптографические доказательства с нулевым разглашением**: Позволяет доказать знание секрета без раскрытия самого секрета.

6. **Образовательные цели**: Из-за своей относительной простоты часто используется для обучения основам асимметричной криптографии.

## Реализованный алгоритм (rabin.ts). Полное пошаговое описание работы шифрования и дешифрования

Наша реализация криптосистемы Рабина находится в файле `rabin.ts` и включает следующие основные функции:

### Генерация ключей

```typescript
/**
 * Генерирует простое число Блюма (простое число p, где p ≡ 3 (mod 4))
 */
function generateBlumPrime(bitLength: number): bigint {
  // Простая проверка на простоту (тест Ферма)
  function isProbablePrime(n: bigint): boolean {
    if (n <= 1n) return false
    if (n <= 3n) return true
    if (n % 2n === 0n) return false

    // Тест Ферма с основанием 2
    return modPow(2n, n - 1n, n) === 1n
  }

  // Генерация случайного числа заданной битовой длины
  function generateRandomNumber(bits: number): bigint {
    // Создаем случайное шестнадцатеричное число
    let hex = '0x'
    for (let i = 0; i < Math.ceil(bits / 4); i++) {
      hex += Math.floor(Math.random() * 16).toString(16)
    }

    let num = BigInt(hex)
    // Делаем число нечетным
    if (num % 2n === 0n) num += 1n
    return num
  }

  // Ищем простое число, которое при делении на 4 дает остаток 3
  let prime: bigint
  do {
    // Генерируем случайное число и проверяем его на простоту
    let candidate: bigint
    do {
      candidate = generateRandomNumber(bitLength)
    } while (!isProbablePrime(candidate))

    prime = candidate
  } while (prime % 4n !== 3n)

  return prime
}

/**
 * Генерирует пару ключей для криптосистемы Рабина
 */
function generateKeyPair(bitLength: number = 512): {
  publicKey: bigint
  privateKey: { p: bigint; q: bigint }
} {
  const p = generateBlumPrime(bitLength / 2)
  const q = generateBlumPrime(bitLength / 2)
  const n = p * q
  return { publicKey: n, privateKey: { p, q } }
}
```

Процесс генерации ключей включает следующие шаги:

1. Генерация двух простых чисел Блюма p и q (простые числа, дающие остаток 3 при делении на 4)
2. Для проверки на простоту используется тест Ферма
3. Вычисление открытого ключа n = p × q
4. Формирование пары ключей: открытый ключ (n) и закрытый ключ (p, q)

### Шифрование

```typescript
/**
 * Шифрует сообщение с использованием криптосистемы Рабина
 */
function encrypt(message: bigint, publicKey: bigint): bigint {
  // Используем константу TWO для возведения в степень 2
  return modPow(message, 2n, publicKey)
}
```

Процесс шифрования:

1. Сообщение преобразуется в число типа BigInt
2. Выполняется возведение в квадрат по модулю открытого ключа n
3. Результат является зашифрованным сообщением

### Расшифрование

```typescript
/**
 * Расшифровывает шифротекст с использованием криптосистемы Рабина
 */
function decryptWithPQ(ciphertext: bigint, p: bigint, q: bigint): bigint[] {
  const n = p * q

  // Вычисляем квадратные корни по модулю p и q
  const mp = (p + 1n) / 4n // Показатель степени для p
  const mq = (q + 1n) / 4n // Показатель степени для q

  const root_p_1 = modPow(ciphertext, mp, p)
  const root_p_2 = p - root_p_1
  const root_q_1 = modPow(ciphertext, mq, q)
  const root_q_2 = q - root_q_1

  // Получаем коэффициенты Безу: yp*p + yq*q = 1
  const [, yp, yq] = extendedGCD(p, q)

  // Комбинируем корни, используя Китайскую теорему об остатках
  // Формула: (yp * p * root_q + yq * q * root_p) % n
  const plaintext1 = (yp * p * root_q_1 + yq * q * root_p_1) % n
  const plaintext2 = (yp * p * root_q_2 + yq * q * root_p_1) % n
  const plaintext3 = (yp * p * root_q_1 + yq * q * root_p_2) % n
  const plaintext4 = (yp * p * root_q_2 + yq * q * root_p_2) % n

  // Убеждаемся, что все значения положительные
  const makePositive = (x: bigint) => (x < 0n ? x + n : x)

  return [makePositive(plaintext1), makePositive(plaintext2), makePositive(plaintext3), makePositive(plaintext4)]
}
```

Процесс расшифрования:

1. Вычисление квадратных корней по модулю p и q:

   - Для p: root_p_1 = c^((p+1)/4) mod p и root_p_2 = p - root_p_1
   - Для q: root_q_1 = c^((q+1)/4) mod q и root_q_2 = q - root_q_1

2. Нахождение коэффициентов Безу yp и yq с помощью расширенного алгоритма Евклида:

   ```typescript
   function extendedGCD(a: bigint, b: bigint): [bigint, bigint, bigint] {
     let remainder_old = a
     let remainder_new = b
     let bezout_a_old = 1n
     let bezout_a_new = 0n
     let bezout_b_old = 0n
     let bezout_b_new = 1n

     while (remainder_new !== 0n) {
       const quotient = remainder_old / remainder_new

       // Обновляем остатки
       const temp_remainder = remainder_new
       remainder_new = remainder_old - quotient * remainder_new
       remainder_old = temp_remainder

       // Обновляем коэффициенты Безу для a
       const temp_bezout_a = bezout_a_new
       bezout_a_new = bezout_a_old - quotient * bezout_a_new
       bezout_a_old = temp_bezout_a

       // Обновляем коэффициенты Безу для b
       const temp_bezout_b = bezout_b_new
       bezout_b_new = bezout_b_old - quotient * bezout_b_new
       bezout_b_old = temp_bezout_b
     }

     return [remainder_old, bezout_a_old, bezout_b_old] // [gcd, x, y]
   }
   ```

3. Комбинирование корней с использованием Китайской теоремы об остатках для получения четырех возможных значений исходного сообщения

4. Определение правильного сообщения из четырех возможных вариантов:

   ```typescript
   // Пример определения правильного сообщения
   const decryptedValues = decrypt(encrypted, privateKey)
   let originalMessage = null

   for (const value of decryptedValues) {
     try {
       const decryptedString = bigIntToString(value)
       if (isValidMessage(decryptedString)) {
         originalMessage = decryptedString
         break
       }
     } catch {
       // Недопустимая строка UTF-8
     }
   }
   ```

### Вспомогательные функции

Для работы с текстовыми сообщениями реализованы функции преобразования строк в BigInt и обратно:

```typescript
/**
 * Вспомогательная функция для преобразования строки в BigInt
 */
function stringToBigInt(str: string): bigint {
  const encoder = new TextEncoder()
  const bytes = encoder.encode(str)

  // Преобразуем байты в шестнадцатеричную строку
  let hex = '0x'
  for (const byte of bytes) {
    hex += byte.toString(16).padStart(2, '0')
  }

  return BigInt(hex)
}

/**
 * Вспомогательная функция для преобразования BigInt в строку
 */
function bigIntToString(bigint: bigint): string {
  // Преобразуем BigInt в шестнадцатеричную строку
  let hex = bigint.toString(16)

  // Добавляем ведущий ноль, если длина нечетная
  if (hex.length % 2 !== 0) {
    hex = '0' + hex
  }

  // Преобразуем шестнадцатеричную строку в массив байтов
  const bytes = new Uint8Array(hex.length / 2)
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16)
  }

  // Преобразуем байты в строку
  const decoder = new TextDecoder()
  return decoder.decode(bytes)
}
```

## Разработанное приложение

### Обзор

Приложение представляет собой интерактивный мессенджер, демонстрирующий работу криптосистемы Рабина в контексте защищенного обмена сообщениями между двумя пользователями (условно названными Алиса и Боб). Приложение позволяет увидеть процесс шифрования и расшифрования сообщений.

### Созданные функции

1. **Генерация ключей**:

   - Автоматическая генерация ключей с заданной битовой длиной
   - Возможность ручного ввода простых чисел p и q для создания ключей

2. **Обмен сообщениями**:

   - Отправка зашифрованных сообщений от Алисы к Бобу и наоборот
   - Визуализация процесса шифрования и расшифрования

3. **Логирование**:

   - Логирование всех операций с отображением промежуточных значений
   - Возможность пошагового просмотра процесса шифрования/расшифрования

### Архитектура

Приложение построено на основе современного стека

1. **Технологии**:

   - React
   - TypeScript
   - TailwindCSS
   - Vite

2. **Криптографический модуль**:

   - Модуль `rabin.ts` с реализацией криптосистемы Рабина
   - Использование BigInt для работы с большими числами
   - Оптимизированные алгоритмы для эффективных вычислений

## Уязвимости и методы избегания

### Потенциальные уязвимости

1. **Неоднозначность расшифрования**:

   - Криптосистема Рабина дает четыре возможных варианта исходного сообщения
   - Решение: использование дополнительной информации (например, формата сообщения) для определения правильного варианта

2. **Уязвимость к атаке на основе подобранного шифротекста**:

   - Возможность получения информации о закрытом ключе при наличии доступа к функции расшифрования
   - Решение: использование дополнительного паддинга и проверок целостности

3. **Факторизация модуля**:

   - Безопасность системы зависит от сложности факторизации числа n
   - Решение: использование достаточно больших простых чисел (2048 бит и более)

4. **Атаки по побочным каналам**:
   - Возможность получения информации о закрытом ключе через анализ времени выполнения операций
   - Решение: реализация с постоянным временем выполнения операций

### Методы повышения безопасности

1. **Оптимальный выбор параметров**:

   - Использование простых чисел достаточной длины (минимум 1024 бита для каждого)
   - Выбор p и q примерно одинаковой длины, но значительно отличающихся друг от друга

2. **Структурированные сообщения**:

   - Добавление к сообщению известной структуры или контрольной суммы
   - Использование схем паддинга (например, OAEP)

3. **Комбинирование с другими криптосистемами**:

   - Использование криптосистемы Рабина для обмена ключами
   - Шифрование основного сообщения симметричным алгоритмом

4. **Регулярное обновление ключей**:
   - Периодическая смена ключевой пары для минимизации рисков

## Выводы

Криптосистема Рабина представляет собой элегантное и математически обоснованное решение для асимметричного шифрования. Её основные преимущества:

1. **Математическая доказуемость безопасности**: Эквивалентность проблеме факторизации больших чисел делает криптосистему Рабина теоретически обоснованной.

2. **Эффективность шифрования**: Операция шифрования требует всего одного возведения в квадрат по модулю, что делает её очень быстрой.

3. **Образовательная ценность**: Относительная простота алгоритма делает его отличным инструментом для изучения основ асимметричной криптографии.

Однако, криптосистема имеет и свои ограничения:

1. **Неоднозначность расшифрования**: Необходимость выбора из четырех возможных вариантов исходного сообщения усложняет практическое применение.

2. **Уязвимость к специфическим атакам**: Требуется дополнительная защита от атак на основе подобранного шифротекста.
