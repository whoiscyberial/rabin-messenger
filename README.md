# Мессенджер на основе криптосистемы Рабина

Это приложение демонстрирует работу криптосистемы Рабина в контексте защищенного обмена сообщениями между двумя пользователями (Алисой и Бобом).

## Криптосистема Рабина: объяснение алгоритма

Криптосистема Рабина — это асимметричная криптосистема, предложенная Майклом Рабином в 1979 году. Её безопасность математически эквивалентна сложности факторизации больших чисел.

### Основные принципы

Криптосистема основана на сложности извлечения квадратного корня по модулю составного числа. Если известны простые множители этого числа, задача становится вычислительно простой, что и является основой для асимметричного шифрования.

### Генерация ключей

1. Выбираем два больших простых числа p и q, где p ≡ 3 (mod 4) и q ≡ 3 (mod 4) — такие числа называются числами Блюма
2. Вычисляем n = p × q
3. **Открытый ключ**: n
4. **Закрытый ключ**: (p, q)

```typescript
/**
 * Генерирует простое число Блюма (простое число p, где p ≡ 3 (mod 4))
 */
function generateBlumPrime(bitLength: number): bigint {
  let p: bigint
  do {
    p = generateRandomPrime(bitLength)
  } while (p % 4n !== 3n)

  return p
}

/**
 * Генерирует пару ключей для криптосистемы Рабина
 */
function generateKeyPair(bitLength: number = 512): {
  publicKey: bigint
  privateKey: { p: bigint; q: bigint }
} {
  const p = generateBlumPrime(bitLength / 2)
  const q = generateBlumPrime(bitLength / 2)
  const n = p * q
  return { publicKey: n, privateKey: { p, q } }
}
```

### Шифрование

Процесс шифрования в криптосистеме Рабина чрезвычайно прост:

1. Преобразуем сообщение m в число (убедившись, что m < n)
2. Вычисляем c = m² mod n
3. c — это зашифрованное сообщение

```typescript
/**
 * Шифрует сообщение с использованием криптосистемы Рабина
 */
function encrypt(message: bigint, publicKey: bigint): bigint {
  return (message * message) % publicKey
}

// Пример шифрования текстового сообщения
const message = 'Привет'
const messageBigInt = stringToBigInt(message)
const encrypted = encrypt(messageBigInt, publicKey)
```

### Расшифрование

Расшифрование сложнее и требует знания закрытого ключа (p, q):

1. Вычисляем mp = c^((p+1)/4) mod p
2. Вычисляем mq = c^((q+1)/4) mod q
3. Используем расширенный алгоритм Евклида для нахождения коэффициентов Безу yp и yq, таких что yp·p + yq·q = 1
4. Получаем четыре возможных значения исходного сообщения:
   - r₁ = (yp·p·mq + yq·q·mp) mod n
   - r₂ = (yp·p·mq - yq·q·mp) mod n
   - r₃ = n - r₁
   - r₄ = n - r₂

```typescript
/**
 * Расшифровывает шифротекст с использованием криптосистемы Рабина
 */
function decrypt(ciphertext: bigint, privateKey: { p: bigint; q: bigint }): bigint[] {
  const { p, q } = privateKey
  const n = p * q

  // Вычисляем корни по модулю p и q
  const p1 = modPow(ciphertext, (p + 1n) / 4n, p)
  const p2 = p - p1
  const q1 = modPow(ciphertext, (q + 1n) / 4n, q)
  const q2 = q - q1

  // Получаем коэффициенты Безу
  const [, yp, yq] = extendedGCD(p, q)

  // Вычисляем четыре возможных открытых текста
  const d1 = (yp * p * q1 + yq * q * p1) % n
  const d2 = (yp * p * q2 + yq * q * p1) % n
  const d3 = (yp * p * q1 + yq * q * p2) % n
  const d4 = (yp * p * q2 + yq * q * p2) % n

  // Убеждаемся, что все значения положительные
  return [d1 < 0n ? d1 + n : d1, d2 < 0n ? d2 + n : d2, d3 < 0n ? d3 + n : d3, d4 < 0n ? d4 + n : d4]
}
```

### Определение правильного сообщения

Поскольку расшифрование даёт четыре возможных значения, необходимо определить, какое из них является исходным сообщением. В нашем приложении мы проверяем, какое из расшифрованных значений может быть корректно преобразовано в строку UTF-8 и соответствует ожидаемому формату сообщения:

```typescript
// Пример определения правильного сообщения
const decryptedValues = decrypt(encrypted, privateKey)
let originalMessage = null

for (const value of decryptedValues) {
  try {
    const decryptedString = bigIntToString(value)
    if (isValidMessage(decryptedString)) {
      originalMessage = decryptedString
      break
    }
  } catch {
    // Недопустимая строка UTF-8
  }
}
```

## Особенности и преимущества

- **Эффективность шифрования**: Шифрование требует всего одной операции возведения в квадрат по модулю, что делает его очень быстрым.
- **Математическая доказуемость**: Безопасность криптосистемы Рабина математически эквивалентна сложности факторизации, что делает её теоретически более обоснованной, чем некоторые другие криптосистемы.
- **Неоднозначность расшифрования**: Основной недостаток — получение четырех возможных вариантов исходного сообщения, что требует дополнительных механизмов для определения правильного.

## Пример с малыми числами

Для наглядности рассмотрим пример с небольшими числами:

1. Пусть p = 7, q = 11 (оба ≡ 3 mod 4)
2. n = 7 × 11 = 77 (открытый ключ)
3. Сообщение m = 10
4. Шифрование: c = 10² mod 77 = 100 mod 77 = 23
5. Расшифрование даст четыре значения: 10, 67, 47 и 30, одно из которых (10) является исходным сообщением

```typescript
// Пример с малыми числами
const p = 7n
const q = 11n
const n = p * q // 77n
const message = 10n

// Шифрование
const encrypted = (message * message) % n // 23n

// Расшифрование
const decrypted = decrypt(encrypted, { p, q })
console.log(`Зашифрованное значение: ${encrypted}`)
console.log(`Возможные расшифрованные значения: ${decrypted.join(', ')}`)
// Вывод: Возможные расшифрованные значения: 10, 67, 47, 30
```

## Запуск приложения

Для запуска приложения выполните следующие команды:

```bash
# Установка зависимостей
npm install

# Запуск в режиме разработки
npm run dev
```

## Функциональность приложения

Приложение предоставляет следующие возможности:

1. **Генерация ключей**: Создание пары ключей для криптосистемы Рабина (случайная генерация или ручной ввод)
2. **Обмен сообщениями**: Защищенный обмен сообщениями между Алисой и Бобом
3. **Визуализация процесса**: Подробный журнал процесса шифрования и расшифрования

## Технологии

- TypeScript
- React
- Vite
- TailwindCSS
